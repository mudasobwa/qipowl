{"name":"qipowl","tagline":"the next generation markup environment for virtually everything","body":"![qipowl](https://github.com/mudasobwa/typogrowl/raw/master/images/owl.png)\r\n\r\nThe main idea of _qipowl_ is to yield the power of \r\n[DSL in Ruby](http://jroller.com/rolsen/entry/building_a_dsl_in_ruby).\r\nThe whole input text is treated neither more nor less than `DSL`. \r\nThat gives the user an ability to make virtually every term in input text\r\nthe _operating entity_.\r\n\r\n## Intro\r\n\r\nEverybody knows that parsing is annoying, error-prone and generally hazardous. That’s because the common old-school approach to parsing suc^W^W failed.\r\n\r\nThe problems are greatly exaggerated. The only thing we need to make the parsing process pleasant is to join _bootstrapping techniques_, _Ruby DSL abilities_ and a bit of additional _Ruby coding_.\r\n\r\nLike Baron Münchhausen, who allegedly pulled himself and the horse on which he was sitting out of a swamp by his own hair (or like [Ouroboros](http://en.wikipedia.org/wiki/Ouroboros) if one prefers serpentariums to swamps), the text to be parsed should… Well, it should **parse itself**.\r\n\r\n![illustration by Oskar Herrfurth](http://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Muenchhausen_Herrfurth_7_500x789.jpg/152px-Muenchhausen_Herrfurth_7_500x789.jpg)\r\n\r\nRuby DSL has _all_ the prerequisites for that. Let’s see.\r\n\r\n## Bowler Basics\r\n\r\nThe main principle of **qipowl** is:\r\n\r\n#### All the input text is interpreted as Ruby code.\r\n\r\nThere is a rake¹ on our way, and we’re near to get on the forehead, so let’s watch our steps:\r\n\r\n* Get rid of all the symbols, which may confuse ruby interpreter (e. g. `ASCII`); we simply `gsub` all the single-byte symbols to their “[fullwidth](http://en.wikipedia.org/wiki/Fullwidth#In_Unicode)” representation.\r\n* Split input text to, say, “paragraphs” (by empty lines).\r\n* Process each line of result as if it was plain Ruby (`eval`; it’s safe).\r\n* `gsub` wide characters back to `Latin1`.\r\n\r\nAs we have done the four steps above, we’ve run into troubles with “undefined methods/constants” errors. Let’s see why. For instance, we are to proceed with the following string:\r\n\r\n    I'm Brian, and so's my wife!\r\n\r\nAfter 1st step we yield:\r\n\r\n    Ｉ＇ｍ Ｂｒｉａｎ， ａｎｄ ｓｏ＇ｓ ｍｙ ｗｉｆｅ\r\n\r\nStep 2) is omitted, since we have the only string in the input. Now let’s give a chance to step 3). If we’d stop here and try to suggest, how ruby interpreter will be dealing with this garbage. Let’s take a look at this _valid_ ruby command:\r\n\r\n    puts rand hash\r\n\r\nIt surprisingly puts a huge random value. Ruby evaluates `hash`, passes the result of evaluation to `rand`, evaluates `rand` and, chaining the result, finally prints it out. Aha! But there is no such ruby functions like `ｗｉｆｅ`, `ｓｏ＇ｓ` or `Ｉ＇ｍ`. It’s time for `method_missing` come to scene.\r\n\r\n    def respond_to?\r\n      true\r\n    end\r\n\r\n    def method_missing method, *args, &block\r\n      method, *args = special_handler(method, *args, &block) \\\r\n        if self.private_methods.include?(:special_handler)\r\n      [method, args].flatten\r\n    end\r\n\r\nHere we simply pass the parameters further in the chain, giving an aspect for intervention: if any of descendants have had `special_handler` method overwritten, it’ll be called.\r\n\r\nSince we have these two methods **only**, we already have a void parser. It means our string will be executed as ruby code without any errors from within class, containing these methods.\r\n\r\n    def parse string\r\n      eval 'Ｉ＇ｍ Ｂｒｉａｎ， ａｎｄ ｓｏ＇ｓ ｍｙ ｗｉｆｅ'\r\n    end\r\n\r\n    # ⇒ 'Ｉ＇ｍ Ｂｒｉａｎ， ａｎｄ ｓｏ＇ｓ ｍｙ ｗｉｆｅ'\r\n\r\nNice scaffold, isn’t it? Here and further we call this base class `Bowler`.\r\n\r\n____________________\r\n¹ True rake, I mean.\r\n\r\n## Bowler Scaffold\r\n\r\nIf it looks like a pan, stores like a pan, and sizzles like a pan, then it is a bowler. \r\n\r\nI choose the name `Bowler` for the base class because every process usually has three stages:\r\n\r\n* prepare\r\n* perform\r\n* ??? (I’ve heard there is no such word “postpare” in English\r\n\r\nMy process also has these stages and I needed clear easy-to-remember names for them. Here we are:\r\n\r\n* defreeze\r\n* roast\r\n* serveup\r\n\r\nSince the bowler introduced in the [previous chapter](/mudasobwa/qipowl/wiki/1.-Bowler-Basics) has a middling meaning, we need more built-in helpers for future use. First of all, we need to fullwidth the input in `defreeze`, to break in into “paragraphs” in `roast` and to `gsub` it back to normal characters in `serveup`. Secondary, we need to be able to store some processing rules in config file (which is to be `YAML` and should be loaded by base class.)\r\n\r\nThat’s all for now, we’ll turn back to this class later.\r\n\r\n## Processing chain\r\n\r\nWithin default `Bowler`, the input string is simply eaten by ruby interpreter and spitted out then. Not so useful, huh?\r\n\r\nWell, let’s recall that _each_ “word” in input string is currently handled by `method_missing`. What if we **declare** new method within class derived from `Bowler`?\r\n\r\n    # Ｉ＇ｍ Ｂｒｉａｎ ａｎｄ ｓｏ＇ｓ ｍｙ ｗｉｆｅ\r\n    class Herald\r\n      def Ｂｒｉａｎ *args\r\n        me = __callee__\r\n        [me, ', the Herald, honour me,', *args]\r\n      end\r\n    end\r\n\r\nAfter we have the input string processed by this class, the output became:\r\n\r\n    I'm Brian, the Herald, honour me, and so's my wife!\r\n\r\nCute, huh?\r\n\r\nThere are ready-to-use examples for command line parser, markdown-like markup to HTML parser and even YAML loader provided.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}